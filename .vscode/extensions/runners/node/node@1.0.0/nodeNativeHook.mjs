import*as path from"path";import{readFileSync}from"fs";import{pathToFileURL}from"url";let port,testRunData,nextLoadIdx=1;const loadPromises=new Map,originalNodeTestUrl="node:test",customTestModulePath="./wallaby-node-test.mjs",customTestModuleUrl=pathToFileURL(customTestModulePath).href;let normalizedLocalProjectDir,normalizedProjectCacheDir,resolvers=[],loaders=[],active=!1;const normalizePath=e=>e?e.replace("win32"===process.platform?"file:///":"file://","").split(path.sep).join("/"):e,getFileData=e=>{-1!==e.indexOf("?")&&(e=e.substr(0,e.indexOf("?")));let t=normalizePath(normalizePath(e).replace(normalizedLocalProjectDir,"").replace(normalizedProjectCacheDir,""));return"/"===t[0]&&(t=t.substr(1)),global.$_$tracer._filePathToFileData[t]};export async function initialize(e){global.$_$tracer={},Object.keys(e.testRunData.globals).forEach((t=>{global[t]=e.testRunData.globals[t]})),Object.keys(e.testRunData.tracer).forEach((t=>{global.$_$tracer[t]=e.testRunData.tracer[t]})),normalizedLocalProjectDir=normalizePath(path.dirname(global.wallaby._localNodeModules)),normalizedProjectCacheDir=normalizePath(global.wallaby._originalCacheRoot),testRunData=e.testRunData,port=e.port,port.onmessage=e=>{if("loadResult"===e.data.type){const{idx:t,result:a,error:r}=e.data,{resolve:o,reject:s}=loadPromises.get(e.data.idx);loadPromises.delete(t),r?s(r):o(a)}},port.unref();let t=!1;for(const e of global.wallaby.esmHooks)switch(e){case"@swc-node/register/esm-register":if(!t&&global.wallaby.swcPath){const e=await import(path.join(global.wallaby.swcPath,"esm/esm.mjs"));resolvers.push(e.resolve),loaders.push(e.load),t=!0}break;case"ts-node/esm":if(!t&&global.wallaby.tsNodePath){const e=await import(path.join(global.wallaby.tsNodePath,"esm.mjs"));resolvers.push(e.resolve),loaders.push(e.load),t=!0}break;case"tsx/esm":if(!t&&global.wallaby.tsxPath){const e=await import(path.join(global.wallaby.tsxPath,"dist/esm/index.mjs"));e.initialize({}),resolvers.push(e.resolve),loaders.push(e.load),t=!0}break;default:const a=await import(e);a.resolve&&resolvers.push(a.resolve),a.load&&loaders.push(a.load)}active=!0}export async function resolve(e,t,a){if(!active)return t.parentURL===import.meta.url&&(t.parentURL=pathToFileURL(path.join(global.wallaby.localProjectRoot,"index.js"))),a(e,t);if("node:test"===e){const e=getFileData(t.parentURL);return e&&e.test?{url:t.parentURL===customTestModuleUrl?"node:test":customTestModuleUrl,shortCircuit:!0}:{url:"node:test",shortCircuit:!0}}const r=[...resolvers,a],o=async(e,t)=>r.shift()(e,t,o);return o(e,t)}export async function load(e,t,a){if(!active)return a(e,t);if("builtin"===t.format)return await a(e,t);if(e===customTestModuleUrl)return{format:"module",shortCircuit:!0,source:"import * as originalTest from 'node:test';\n\nconst wrapFunction = (name, fn) => {\n  return function(...args) {\n    const updatedArgs = global.$_$tracer.nodeNativeEvent('before:' + name, args);\n    try {\n      return fn(...updatedArgs);\n    } finally {\n      global.$_$tracer.nodeNativeEvent('after:' + name, args);\n    }\n  };\n};\n\n// Wrap the desired functions\nconst wrapped = {};\nfor (const [key, value] of Object.entries(originalTest)) {\n  wrapped[key] = typeof value === 'function' ? wrapFunction(key, value) : value;\n}\n\nif (global.$_$profileRun) {\n  wrapped.before(async () => {\n    const inspector = await import('inspector');\n    global.$_$inspectorSession = new inspector.Session();\n    global.$_$inspectorSession.connect();\n\n    await new Promise((resolve) => {\n      global.$_$inspectorSession.post('Profiler.enable', () => {\n        global.$_$inspectorSession.post('Profiler.start', () => {\n          resolve();\n        });\n      });\n    });\n  });\n}\n\nwrapped.test.only = wrapped.only;\nwrapped.test.todo = wrapped.todo;\nwrapped.test.skip = wrapped.skip;\nwrapped.it.only = wrapped.only;\nwrapped.it.todo = wrapped.todo;\nwrapped.it.skip = wrapped.skip;\n\nexport default wrapped.test;\nexport * from 'node:test';\nexport const {\n  describe = wrapped.describe,\n  it = wrapped.it,\n  test = wrapped.test,\n  suite = wrapped.suite,\n  skip = wrapped.skip,\n  todo = wrapped.todo,\n  only = wrapped.only,\n} = wrapped;"};const r=getFileData(e.toString());let o=!1;const s=[async(e,t,a)=>{try{return await a(e,t)}catch(e){if(!o)throw e;const t=()=>{try{if(e&&e.message&&"string"==typeof e.message){const t=/(?:\r\n|\r|\n)([^\r\n]+)\((\d+),(\d+)\):/,a=e.message.match(t);if(a){const[,,e]=a;return parseInt(e,10)-1}}}catch(e){}return 0},a=e.toString().replace(/^Error:(\s*)/,"");return{format:"module",shortCircuit:!0,source:`${"".padStart(t(),"\n")}throw new Error(${JSON.stringify(a)}); export default {}`}}},async(e,t,a)=>{const o=await a(e,t);if(!o.source)return o;if(!r||!r.instrument)return o;const s=nextLoadIdx++,n=await new Promise(((t,a)=>{loadPromises.set(s,{resolve:t,reject:a}),port.postMessage({type:"load",url:e,idx:s,format:o.format,shortCircuit:o.shortCircuit,source:o.source.toString()})}));return o.source=n.source.toString(),o},...loaders,async(e,t,a)=>{o=!0;try{const o=await a(e,t);return o.source?(r?.inOriginalFilesCache&&(o.source=readFileSync(path.join(global.wallaby._originalCacheRoot,r.path),"utf8")),o):o}catch(e){throw o=!1,e}},async(e,t,a)=>{try{return await a(e,t)}catch(e){throw!e.message||0!==e.message.indexOf('Unknown file extension ".ts"')||3!==global.wallaby.esmHooks.length||global.wallaby.swcPath||global.wallaby.tsNodePath||global.wallaby.tsxPath||(e.message="TypeScript compilation failed.\n\nTry installing `@swc-node/register`, `ts-node`, or `tsx` as a project dependency.\n\n"+e.message),e}},a],n=async(e,t)=>s.shift()(e,t,n);return n(e,t)}